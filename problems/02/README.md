# Задачи по теме «Типы и структуры данных»

* Почти все задачи (кроме 7-й) взяты с сайта [leetcode.com](https://leetcode.com). Оттуда же взяты и шаблоны решений. Это позволит вам перед отправкой протестировать свои решения (потребуется регистрация на сайте) и сократить число итераций сдачи.

1.  (2 балла) [Move Zeroes](https://leetcode.com/problems/move-zeroes/)
	Напишите функцию, принимающую массив целых чисел, которая перемещает нули в конце массива, сохраняя порядок ненулевых элементов. Например, если исходный массив равен `[0,1,0,3,12]`, после применения функции он должен быть равен `[1,3,12,0,0]`. Обратите внимание, что функция не должна ничего возвращаеть, все изменения должны быть сделаны в исходном массиве (т.е. in-place).
	Время работы: `O(n)`. Дополнительная память: `O(1)`.

2.  (3 балла) [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)
	Пусть имеется некоторый отсортированный по возрастанию массив циклически сдвинутый на неизвестное число элементов.
	(Например `[4,5,6,7,0,1,2]` — циклически сдвинутый вправо на 3 массив `[0,1,2,4,5,6,7]`.)
	Найдите минимальный элемент в таком массиве.
	Время работы: `O(log(n))`. Дополнительная память: `O(1)`. В массиве гарантируется отсутствие повторяющихся элементов.

3.  (2 балла) [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)
	Напишите функцию которая развернёт данный односвязный список в обратном порядке и вернёт первый элемент развёрнутого списка.
	Время работы: `O(n)`. Дополнительная память: `O(1)`.

4.  (3 балла) [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)
	На семинаре обсуждалась ситуация, когда в связном списке имеется цикл, т.е. поле `.next` некоторого элемента ссылается на один из предыдущих элементов. Существует алгоритм, который позволяет определить наличие такого цикла используя `O(1)` дополнительной памяти. Найдите и реализуйте этот алгоритм. Пример:
	```python
	class ListNode(object):
	    def __init__(self, x, next=None):
	        self.val = x
	        self.next = next

	lst = ListNode(1, ListNode(2, ListNode(3), ListNode(3)))  # 1 -> 2 -> 3 -> 4
	lst.next.next.next = lst.next  # создаём цикл  1 -> 2 -> 3 -> 4 ↘
								   #                     ↖__________|
	hasCycle(lst)  # -> True
	```

5.  (2 балла) [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)
	Напишите функцию которая принимает строку содержащую только символы `'('`, `')'`, `'{'`, `'}'`, `'['` и `']'` и определяет, является ли скобочное выражение сбалансированым. Например, `"()[]{}"` — сбалансированное скобочное выражение, а `"([)]"` — нет.
	Время работы: `O(n)`. Дополнительная память: `O(n)`.	

6.  (3 балла) [Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)
	Смоделируйте очередь используя только стеки. Вы должны реализовать следующие операции (см. шаблон в коде):
	```
	push(x)  # Добавить элемент в конец очереди
	pop()    # Удалить элемент из начала очереди и вернуть его значение
	peek()   # Вернуть значение элемента из начала очереди не удаляя его
	empty()  # Вернуть True если очередь пуста, иначе False
	```
	`list` в Python можно использовать в качестве стека. При этом разрешается использовать только операции `.append` и `.pop`, доступ по индексам и добавление/удаление элементов не из конца массива запрещены.
	Можно не реализовывать обработку ошибок, т.к. гарантируется что все операции над очередью будут корректны (например, не будет операций `.pop()` или `.peek()` над пустой очередью).
	В задаче не идёт речь об эффективности: все операции могут работать за `O(n)`.

7.  (3 балла) Напишите класс хэш-таблицы фиксированного размера (скажем, 1000) с открытой адресацией и linear probing (т. е. если при вставке мы видим, что ячейка с нужным номером занята, мы идём дальше по всем ячейкам подряд, пока не найдём пустую).
	Класс должен иметь функции вставки и поиска и выглядеть примерно вот так:
	```python
	class HashTable:
	    def __init__(self):
	        # создать массив на 1000 ячеек, в которых будет лежать None
	        ...

	    def add(self, element):
	        # добавить элемент в хэш-таблицу или сообщить, что мест нет
	        ...

	    def find(self, element):
	        # вернуть True, если элемент есть в хэш-таблице, и False, если нет
	        ...
	```
	В качестве хэш-функции можно использовать встроенную функцию `hash()` (точнее, остаток от деления её на размер таблицы).
	Если хотите, можете дописать ещё и функцию удаления, но там не всё так очевидно, как может показаться.

8.	(5 баллов) [LRU Cache](https://leetcode.com/problems/lru-cache/)
	Напишите класс реализующий обсуждённый на семинаре LRU cache a.k.a «история звонков в телефоне».
	Класс должен принимать параметр `capacity`, определяющий максимальное числи элементов, а так же определять два метода:
	* `.get(key)` — возвращает значение по ключу если он есть в кэше, иначе вернёт `-1`
	* `.put(key, value)` — добавить новую пару ключ-значение (или обновить значение, если ключ уже есть в кэше). Если ключа в кэше нет, а количество элементов равно `capacity`, попутно удаляет элемент, к которому дольше всего не обращались.
	
	Пример:
	```python
	cache = LRUCache(2)  # не более двух элементов в кэше

	cache.put(1, 1)
	cache.put(2, 2)
	cache.get(1)     # -> 1
	cache.put(3, 3)  # удаляет ключ 2, добавляет 3
	cache.get(2)     # -> -1 (ключ не найден)
	cache.put(4, 4)  # удаляет ключ 1, добавляет 1
	cache.get(1)     # -> -1 (ключ не найден)
	cache.get(3)     # -> 3
	cache.get(4)     # -> 4
	```

	Операции `put` и `get` должны работать за `O(1)`.

	P.S.: На семинаре обсуждалась реализация кэша через словарь и двусвязный список. При этом предполагалось, что в словаре можно хранить элемент двусвязного списка, чтобы его можно было удалить за `O(1)`. К сожалению, двусвязный список с таким свойством отсутствует в стандартной библиотеке, так что вам придётся реализовать его самим.
