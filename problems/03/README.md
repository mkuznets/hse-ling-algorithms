# Алгоритмы сортировки. Листок 3.

* Дедлайн: **19 февраля 2017, 23:59**
* Каждая задача соответствует одному баллу 10-балльной шкалы.
* Для всех задач есть **шаблоны с кодом**. Именно в них нужно решать задачи, и именно их (**сохраняя имена файлов!**) отправлять в пулл-реквестах. Например: `students/FainaAbramova/03/5_three_sort.py`.
* В пулл-реквесты **не стоит** включать код, не имеющий отношение к решению задачи (тесты, другие реализации и т.п.)
* У первых двух задач тоже есть шаблоны, их нужно оформить в LaTeX. Шаблон с преамбулой можно взять [отсюда](https://www.sharelatex.com/project/58a0f68f6c4adabf4189744d) (он read-only, но вы можете утащить его в свой аккаунт на том же sharelatex).

## Задачи

1.	*Инверсией* в перестановке `$\pi$` называется пара индексов `$(i,j)$` такая что `$i<j$`, но `$\pi_i>\pi_j$`. Докажите, что в перестановке из `$n$` элементов может быть не более `$n(n-1)/2$` инверсий. В какой перестановке количество инверсий ровно `$n(n-1)/2$`?

2.	В доказательстве нижней границы сложности сортировок на основе сравнений фигурировало выражение `$\log_2{n!}$`, которое мы оценивали формулой Стирлинга. Но можно ограничиться и школьной математикой: используя лишь свойство логарифма произведения, докажите более слабое утверждение: `$\log_2{n!} \ge Cn\log_2{n}$`.

3.	Дана квадратная матрица `A` размера `n×n`, заполненная нулями и единицами. Известно, что за исключением элемента `A[i][i]`, значение которого не определено, строка с индексом `i` состоит из нулей, а столбец с индексом `i` — из единиц. Очевидно, что `i` единственно. Напишите функцию, которая возвращает `i`. Время работы алгоритма — `O(n)`.
	*Подсказка:* попробуйте посмотреть на `A[i][j]` как на результат сравнения некоторых элементов `i` и `j`. Вспомните, что максимум из `n` элементов можно найти за `O(n)`.

4.	В сортировке вставками для добавления элемента в отсортированный префикс фактически используется линейный поиск. Однако можно было бы использовать и бинарный поиск для нахождения точного индекса для нового элемента. Это не улучшает асимптотическую сложность — потребуется освободить место для нового элемента, и это по-прежнему линейная операция. Зато (теоретически) это уменьшает число операций сравнения. Реализуйте такую сортировку на основе приведённого в шаблоне кода. Для бинарного поиска используйте функции из модуля `bisect` стандартной библиотеки.

5.	Имеется `n`-элементный массив, в котором только 3 различных элемента: 'B' («blue»), 'R' («red») и 'W' («white»). Реализуйте (на основе процедуры `partition` из алгоритма Quicksort) сортировку такого массива в порядке цветов флага Нидерландов. Время работы: `O(n)`, дополнительная память: `O(1)`.

6.	Напишите функцию на основе Quicksort, возвращающую `m` наименьших элементов исходного массива (не обязательно отсортированных). Время работы: `O(n)`.

7.	Напишите функцию, вычисляющую симметрическую разность двух отсортированных массивов. Гарантируется, что в каждом из массивов нет повторяющихся элементов. *Подсказка:* в качестве вдохновения используйте функцию `merge` из Mergesort.

8.	Даны `n` отрезков на прямой, заданные в виде двух массивов действительных чисел `A` и `B`, где каждый отрезок это `(A[i], B[i])`. Найти максимальное `k`, для которого найдётся точка прямой покрытая `k` отрезками. Время работы: `O(n log(n))`, дополнительная память — `O(1)`.

9.	Некоторые файловые менеджеры сортируют нумерованые файлы вида `1.jpg`, `2.jpg`, `3.jpg`, ... следующим образом:
	```
	1.jpg
	10.jpg
	100.jpg
	11.jpg
	...
	2.jpg
	20.jpg
	21.jpg
	...
	```

	Это результат сортировки с простым посимвольным сравнением. Оно хорошо подходит для сортировки фамилий, но плохо работает с нумероваными файлами: символ `1` «меньше» чем `2`, поэтому `100.jpg` стоит раньше чем `2.jpg`. Именно поэтому к названиям таких файлов часто добавляют нули (например `IMG_0042.jpg` в фотоаппаратах).

	Избавиться от этого помогает [натуральная сортировка](https://en.wikipedia.org/wiki/Natural_sort_order), в которой последовательности цифр в строке считаются за один символ. Напишите функцию `key` для стандартной питоновской функции [sorted](https://docs.python.org/3.6/library/functions.html#sorted), которая реализует натуральную сортировку строк состоищих из символов `a-z` и `0-9`. Функция не должна использовать регулярные выражения.

	P.S.: обратите внимание: в отличие от рассказанного на лекции примера, `sorted` принимает не функцию сравнивающую два элемента, а функцию отображающую элементы массива на некоторое множество сравнимых объектов (чисел, строк и т.п.), которые потом используются для сортировки.

10.	В среде `Bash` натуральная сортировка строк из файла производится командой `sort` с ключом `-V`:

	```
	$ # Содержимое файла
	$ cat file.txt
	img-19
	img-1
	img-3
	img-20
	.img
	_img

	$ sort -V file.txt
	.img
	img-1
	img-3
	img-19
	img-20
	_img
	```

	Однако, как можно заметить, порядок символов тут отличается от кодировки [ASCII](https://en.wikipedia.org/wiki/ASCII#Printable_characters). Например, в ASCII вся пунктуация идёт перед буквами, а в `sort`, как видно на примере, ­это не так.

	Исследуйте то как работает эта команда и напишите функцию `key` для стандартной функции `sorted`, чтобы та повторяла поведение `sort -V`. Можете ограничиться строками из печатаемых символов ASCII таблицы. Проверить работает ли сортировка идентично можно следующей командой:

	```
	diff <(python3 ./10_pysort.py file.txt) <(sort -V file.txt)
	```

	Она сравнивает результаты сортировки и не печатает ничего, если они совпадают. В противном случае выводит отличающиеся строки.
